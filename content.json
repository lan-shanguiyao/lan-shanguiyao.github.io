{"meta":{"title":"DunLan's Island","subtitle":"DunLan's Island","description":"当群星数亿年前爆炸时，它们形成了这个世界中的一切。我们所认知的一切，都是星辰。","author":"DunLan","url":"https://lan-shanguiyao.github.io","root":"/"},"pages":[{"title":"about","date":"2020-02-07T03:30:32.000Z","updated":"2020-02-07T03:33:03.000Z","comments":true,"path":"about/index.html","permalink":"https://lan-shanguiyao.github.io/about/","excerpt":"","text":""},{"title":"categories","date":"2020-02-07T03:31:06.000Z","updated":"2020-02-07T05:47:07.000Z","comments":true,"path":"categories/index.html","permalink":"https://lan-shanguiyao.github.io/categories/","excerpt":"","text":""},{"title":"tags","date":"2020-02-07T03:29:04.000Z","updated":"2020-02-07T05:46:45.000Z","comments":true,"path":"tags/index.html","permalink":"https://lan-shanguiyao.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"如何在Win10中禁止对特定网站的访问","slug":"baidu","date":"2020-04-16T06:14:15.000Z","updated":"2020-05-06T01:34:35.499Z","comments":true,"path":"2020/04/16/baidu/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/04/16/baidu/","excerpt":"如何在Win10中禁止对特定网站的访问 网上的教程，大多数都是说证书被吊销后如何访问一个网站，今天我要反其道而行之，要主动吊销一个网站的证书，禁止在我的电脑上访问它。","text":"如何在Win10中禁止对特定网站的访问 网上的教程，大多数都是说证书被吊销后如何访问一个网站，今天我要反其道而行之，要主动吊销一个网站的证书，禁止在我的电脑上访问它。 本文以百度为例，讲述如何在你的电脑上阻止对百度的访问 本文由知乎上的 这篇文章 启发而来，这两种方法有异曲同工之妙，不过本文更注重的是与百度这个公司所有服务的屏蔽，而不单单是软件。但本文无法避免由不安全的上网习惯或者疏忽导致的软件捆绑安装问题 首先需要打开百度 然后导出百度的证书到本机 本文能实现的效果也如下图所示 打开设置，搜索“证书”并打开“计算机证书” （此处可能需要Win10专业版） 导入百度的证书 至此 www.baidu.com 在电脑上就被彻底屏蔽掉了","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://lan-shanguiyao.github.io/tags/Windows/"}]},{"title":"Win10 WSL中搭建.NET开发环境","slug":"WSLtitle","date":"2020-03-03T11:24:22.000Z","updated":"2020-05-05T13:01:50.000Z","comments":true,"path":"2020/03/03/WSLtitle/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/03/03/WSLtitle/","excerpt":"Win10 WSL中搭建.NET开发环境 此方法适用于电脑运行虚拟机卡顿（比如我）或电脑剩余空间不足以安装虚拟机的同学。 优点：坑相对较少，节约内存、储存空间 缺点：没有图形化界面等，仅支持 Win10","text":"Win10 WSL中搭建.NET开发环境 此方法适用于电脑运行虚拟机卡顿（比如我）或电脑剩余空间不足以安装虚拟机的同学。 优点：坑相对较少，节约内存、储存空间 缺点：没有图形化界面等，仅支持 Win10 安装方法如下： Win10 开启 WSL Win10 版本需高于 1709 ，版本号在 “设置” -“系统”-“关于”里可以找到 在“控制面板”里找到并打开“启用或关闭 Windows 功能” ，然后滚动至底部，如截图所示，勾选 “适用于 Linux 的 Windows 子系统”，点击确定。它将会下载安装需要的包。 下载安装 Visual Studio Code 下载并安装 安装如下插件：C#；Remote-WSL、Remote-SSH 、Remote - SSH: Editing Configuration Files、Remote Development、Remote - Containers。剩余插件自行安装，比如Chinese (Simplified) Language Pack for Visual Studio Code等。 在 Win10 Microsoft Store 中搜索并安装 Ubuntu 搜索结果有多个 原则上安装哪一个并不影响使用，但为统一起见，建议安装 Ubuntu 通过查阅版本号可知为 Ubuntu 18.04.2 LTS 安装完成后自行设置用户名与密码 根据 Microsoft Docs ：Ubuntu 18.04 包管理器 - 安装 .NET Core 安装.NET Core ,最少安装完 .NET Core SDK ，也可以均安装。如有疑问，可以先自行查阅上文。 命令行命令举例: * 新建项目: `~$ dotnet new console -o myapp` * 运行项目: `~$ dotnet run` 剩余命令参考： https://dotnet.microsoft.com/learn/dotnet/hello-world-tutorial/next https://docs.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio-code 打开 VS Code，按下图操作，即可 大功告成,可以开始使用了。","categories":[{"name":"WSL","slug":"WSL","permalink":"https://lan-shanguiyao.github.io/categories/WSL/"}],"tags":[{"name":".NET","slug":"NET","permalink":"https://lan-shanguiyao.github.io/tags/NET/"},{"name":"C#","slug":"C","permalink":"https://lan-shanguiyao.github.io/tags/C/"},{"name":"WSL","slug":"WSL","permalink":"https://lan-shanguiyao.github.io/tags/WSL/"}]},{"title":"数据结构与OOP课程设计题目 文件目录显示","slug":"oop","date":"2020-02-17T03:54:01.000Z","updated":"2020-05-06T10:45:14.966Z","comments":true,"path":"2020/02/17/oop/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/02/17/oop/","excerpt":"数据结构与OOP课程设计题目 文件目录显示 问题描述 ​ 要求在给出Unix或windows下目录和文件信息的前提下，编程实现将其排列成一棵具有一定缩进的树。","text":"数据结构与OOP课程设计题目 文件目录显示 问题描述 ​ 要求在给出Unix或windows下目录和文件信息的前提下，编程实现将其排列成一棵具有一定缩进的树。 解决问题 ​ 题目说了给出文件信息，我们可以读取文件信息，存到一颗 K-ary tree 中，在按一定的缩进输出就可以了，难点呢就是该如何建立一颗 K-ary tree ，子节点的数目是不确定的。除此之外没有啥难点。 ​ 但是，C++ 17 标准都出了，我们可以利用一下新出的特性嘛，这样，30行内解决问题岂不很爽。只需要借助 path 类中的几个相关函数，就可以解决问题了。当然，调用 cmd 中的 tree 命令也能做到这一点，代码量会更少。 ​ 三种方法的区别主要是在 cmd 是直接调用的系统命令 ，path 类中有一个C++已经帮我们写好的树形结构，而第三种则是我们自己去实现树形结构。 ​ 综上所述呢，这题是一道名副其实的水题。代码如下。 cmd #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;stdlib.h&gt; using namespace std; int main() { string cdstr; cout &lt;&lt; \"输入文件夹路径\" &lt;&lt; endl; cin &gt;&gt; cdstr; cdstr = \"tree /f \" + cdstr; system(cdstr.c_str()); return 0; } 用 C++ 17 中的标准库即可完成 //本项目基于 ISO C++17 标准 #include &lt;iostream&gt; #include &lt;filesystem&gt; using namespace std; using namespace filesystem; inline void print(int n) { for (int i = 0; i &lt; n; ++i) cout &lt;&lt; \" \"; } int main() { string s; cout &lt;&lt; \"输入文件夹路径（绝对路径）：\" &lt;&lt; endl; cin &gt;&gt; s; path str(s); if (!exists(str)) { return 1; }//确认路径存在 directory_entry entry(str);//文件入口 recursive_directory_iterator list(str);//文件入口容器 for (auto&amp; it : list) { print(list.depth()); cout &lt;&lt; it.path().filename() &lt;&lt; endl; } return 0; } 自己造的轮子 //本项目基于 ISO C++17 标准 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;list&gt; #include &lt;fstream&gt; #include &lt;regex&gt; using namespace std; struct Node { Node():parent(nullptr), flag(true), depth(0) {} Node(const string&amp; e): data(e), parent(nullptr), flag(true), depth(0) {} //data string data;//数据域 Node* parent;//父节点 bool flag;//是否可以有子节点，即，该节点是否为文件夹 vector&lt;Node*&gt;child;//子节点 unsigned depth;//树深,即当前节点所处的层数 }; //文件IO class IO { public: vector&lt;string&gt; FileData; void InPut(const string&amp; name) { InFile.open(name, ios_base::in); //如果文件打开失败 if (!InFile.is_open()) { cout &lt;&lt; \"File can't open\" &lt;&lt; endl; exit(EXIT_FAILURE); } char a[501]; int i = 0; while (InFile.getline(a, sizeof(a))) FileData.push_back(a); InFile.clear(); InFile.close(); } void OutPut(const string&amp; name, const vector&lt;string&gt;&amp; data)//输出文件名，输出的行数，输出的数据 { OutFile.open(name, ios_base::out); for (unsigned i = 0; i &lt; data.size(); ++i) OutFile &lt;&lt; data[i] &lt;&lt; endl; OutFile.close(); } //曲线救国,不符合 IO 类的通用性，慎用，使用时，三个函数必须全部使用 void OutInit1(const string&amp; filename) { OutFile.open(filename, ios_base::out); } void OutInit(const string&amp; data) { OutFile &lt;&lt; data; } void OutInit2() { OutFile.close(); } private: fstream InFile;//文件输入 ofstream OutFile;//文件输出 string FileName;//文件名 }; //一个KTree类的对象就是一个 k-ary tree class KTree { public: KTree():_size(0), _root(nullptr), _height(0) {} bool Empty() { return !_root; }//判空 Node* Root()const { return _root; }//root unsigned Size()const { return _size; }//size //插入 //插入根节点 Node* InsertAsRoot(const string&amp; e) { _size = 1; return _root = new Node(e); } //插入子节点 e 作为 x 的孩子插入 Node* InsertAsChild(const string&amp; e, Node* x) { _size++; Node* a = new Node(e); a-&gt;parent = x; a-&gt;depth = x-&gt;depth + 1; x-&gt;child.push_back(a); return a; } //遍历 void Trav(Node* e, IO&amp; io) { out(e-&gt;depth, io);//利用层数来显示次序 io.OutInit(e-&gt;data); io.OutInit(\"\\n\"); if (e-&gt;child.empty()) return; for (unsigned i = 0; i &lt; e-&gt;child.size(); ++i) Trav(e-&gt;child[i], io); } inline void out(unsigned x, IO&amp; io) { for (unsigned i = 0; i &lt; x; ++i) io.OutInit(\" \"); } //删除 //高度更新 private: Node* _root;//root 节点 unsigned _size;//树的节点个数 unsigned _height;//树高 }; //输入数据处理，存入 k-ary tree 中 void ProcessIn(const vector&lt;string&gt;&amp; data, KTree&amp; tree) { for (unsigned i = 0; i &lt; data.size(); ++i) { unsigned cnt = 0; auto res = data[i].find('\\\\', cnt); vector&lt;string&gt; s; while (res != string::npos) { s.push_back(data[i].substr(cnt, res - cnt)); cnt = res + 1; res = data[i].find('\\\\', cnt); } s.push_back(data[i].substr(cnt)); //后期优化掉下面的循环,似乎没法优化？！ if (i == 0) tree.InsertAsRoot(s[0]); Node* a = tree.Root(); for (unsigned j = 1; j &lt; s.size(); ++j) { bool f = false; for (unsigned k = 0; k &lt; a-&gt;child.size(); ++k) { if (s[j] == a-&gt;child[k]-&gt;data) { f = true; a = a-&gt;child[k]; } } //没找到就作为子节点插入 if (!f) a = tree.InsertAsChild(s[j], a); } } } int main() { IO io; KTree tree; io.InPut(\"Input1.txt\"); ProcessIn(io.FileData, tree); io.OutInit1(\"Output.txt\"); tree.Trav(tree.Root(), io); io.OutInit2(); return 0; }","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://lan-shanguiyao.github.io/tags/C/"}]},{"title":"Last.fm","slug":"Last-fm","date":"2020-02-07T13:04:25.000Z","updated":"2020-05-06T01:53:46.000Z","comments":true,"path":"2020/02/07/Last-fm/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/02/07/Last-fm/","excerpt":"用 Last.fm 记录你听的每一首歌 Last.fm 是什么 Last.fm 是一个以英国为总部的网络电台和音乐社区。","text":"用 Last.fm 记录你听的每一首歌 Last.fm 是什么 Last.fm 是一个以英国为总部的网络电台和音乐社区。 Last.fm 使用的音乐推荐方式称为“Last.fm Scrobbler”，该系统提供安装在用户的电脑播放程序（支持 iTunes、Winamp、Windows Media Player、Foobar2000 等）或随身听设备的插件，记录（scrobbling）用户收听的每一首歌（在线流电台或本地音乐文件）的信息，发送回 Last.fm 数据库，并以其创建该用户的个人音乐品味，显示在该站提供予用户的个人网页上。该站亦提供多种社交网络服务，可让用户推荐或收听合其喜好的音乐。 以上来自 维基百科中对 Last.fm 的介绍。 我是如何与 Last.fm 相遇的 我是想寻找一个平台，来记录自己听歌的数量的，曲目信息足够多并且要准确，支持的音乐平台要多，最好能实现自动记录就是懒，如果有听歌榜单之类的就更好啦。 一开始是选择的豆瓣，无奈豆瓣曲目相当混乱，只能寻找其他平台。然后找到了 Last.fm ，经过一段时间的使用后 Last.fm 主要是一下几点吸引了我： 美观漂亮的音乐榜单 今年许多音乐平台纷纷推出了年度音乐榜单，比如网易云音乐、QQ音乐等等。由于我主要使用的是 Apple Music 很少使用网易云与QQ音乐，而 Apple Music 虽然有一个年度听歌排行榜，但是没有好看的报表分析（就是馋他们的报表分析）。 记录歌曲准确及时 Last.fm 在这一点上做的相当不错，基本只要配置好了同步功能，同步很快而且很准（甚至准的有点过了）。目前我在 Android 与 Windows 上听过的歌都能记录到 Last.fm 上。 Last.fm 还具有推荐功能，这也是我发现新歌曲的一大途径。 Last.fm 能很好的配合 Spotify 对于以后要使用正在使用 Spotify 的我是一个很不错的选择。使用 Spotify 的童鞋请直接看 这里 。 Last.fm 还具有一定的社交功能，这个十分有限，毕竟是 Web2.0时代的网站了。 使用 Last.fm 随时随地记录你听过的歌曲 在 Last.fm 网站上我们可以找到官方支持的平台 很遗憾，出(yi)乎(liao)意(zhi)料(zhong)的没有国内的各大流媒体平台。不过即便如此， Last.fm 依然可以满足我的需求。 同步最方便支持音乐平台最多的：Android 平台 ​ Last.fm 官方提供的程序 Last.fm 只提供了 Spotify、Rdio等平台的支持，所以还需要下载另一个 Scroball for Last.fm 程序，它会监视通知栏来进行记录，所以，有时需要在设置中将播客app、视频app还有浏览器给关闭，防止误记录（使用 Spotify 的童鞋请先关掉这个软件里的 Spotify 记录选项）。 ​ 这样，就能完成 Android 平台的记录，这个平台也几乎是我们听歌最常用的平台。很抱歉我手头没有 iOS 设备所以，我还不大清楚 iOS平台应该怎么样记录。 Window 平台 Windows 平台分为以下两个方面：本地与流媒体 本地播放： foobar2000 这个我们可以在 Last.fm 网站上的 这篇文章 中找到教程。首先我们需要在 Github 上下载一个叫 foo_scrobble 的插件，然后安装到 foobar2000中，安装过程我就不放图了。然后我们按 Ctrl+P，找到如下界面：然后点击橙色的框，此时会弹出浏览器界面，授予权限后，再点击一下，橙色的框会显示&quot;Clear authorization&quot;即完成授权（记得保存设置）。 AIMP AIMP在设置中可以找到 Last.fm ，如下图所示，然后也会打开一个浏览器界面需要授权。不过我觉得 AIMP 在这方面做的体验不怎么样，个人建议使用 foobar2000 。 MusicBee 刚刚接触这个软件，功能有待挖掘，设置 Last.fm 同步也是非常简单的，在首选项-&gt;设置里就可找到 流媒体平台： Listen1 关于它的详细描述，可以参见少数派之前的两篇文章 Listen 1，整合三大音乐平台的 Chrome 扩展 | App+1 、Windows 上的良心国产应用，我们又帮你找了这 5 款 关于它的 Last.fm 设置也非常简单，点击连接，在浏览器页面上完成授权即可。 网易云与QQ音乐 关于网易云音乐与QQ音乐，很遗憾目前关于记录客户端的音乐播放没有好办法没有办法。 如果能在 Web 进行播放，有以下两个插件与脚本可以实现记录。 Apple Music 我对 Apple Music 处于又爱又恨的状态，它与 Spotify 是我认为目前最好的两个音乐流媒体服务（仅个人观点，不喜勿喷），它不用翻墙，价格便宜，曲库全、配合 Apple 家产品使用很舒服（假装我有一台iPhone）；但是 iTunes 在 Windows 上是真的难用，内存占用出奇的高，一个听歌软件你能吃到1G内存？？？还有苹果服务的连接速度与质量也一言难尽，但是，还是要说一句&quot;真香&quot;。 对于苹果感人的优化与网络连接速度，我选择使用 Apple Music Webapp 来解决这个问题。我个人推荐 Musish 整体界面设计与使用体验都很不错，当然也能连接到 Last.fm 在右上角是设置里就能看到，与前面的方式一样，在此不多做赘述。 如果，非要用 Windows 上的 iTunes 听歌，就需要下载 Last.fm 的 官方客户端 来进行记录，登陆账号后即可开始。 Spotify 在 Last.fm 的这个页面上，找到 Spotify ，点击连接，在弹出的浏览器页面中完成授权后，可看到下图，如图所示，我们不再需要记录的app，一个都不需要。（u1s1 Last.fm 配合 Spotify 使用是真的爽）。 更多音乐平台连接 Last.fm 方式可以在这儿找到。 结语 我在二月初使用的 Last.fm 至今，每周我都会看 Last.fm 的收听报告。感觉这就像周记一样记录着你每一周在音乐上的点滴。 同时我还时不时的去看看 Last.fm 的推荐，去发现一些新的歌手，新的歌曲。这些新的发现也会被记录到 Last.fm 上，形成一个推动。这样就一定程度上解决了歌荒的问题。 我个人认为 Last.fm 最重要的一点就是你的音乐记录彻底与流媒体平台切割开来，对某一平台的粘性可以下降到最低，某一平台一旦你觉得不好了，可以随时换掉。你也不再需要某一平台告诉你，你喜欢听什么歌曲。你所有的听歌记录全都被你自己掌控着。 我期待着我看到 Last.fm 2021年度报表的那一刻。 你是不是 Last.fm 用户呢，又有什么关于 Last.fm 想分享的呢？欢迎在评论区分享。","categories":[],"tags":[{"name":"折腾","slug":"折腾","permalink":"https://lan-shanguiyao.github.io/tags/%E6%8A%98%E8%85%BE/"},{"name":"Music","slug":"Music","permalink":"https://lan-shanguiyao.github.io/tags/Music/"}]},{"title":"C++","slug":"C","date":"2020-02-07T09:04:37.000Z","updated":"2020-05-06T01:50:27.734Z","comments":true,"path":"2020/02/07/C/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/02/07/C/","excerpt":"C++ 知识点","text":"C++ 知识点 函数 main函数的形参被称为命令行参数,由操作系统启动程序时初始化,main函数的返回值最终传递给操作系统. 声明函数,形参表只需给出包含完整的类型信息即可,形参名可以省略(不推荐使用). 参数传递 值传递:函数调用时,用实参初始化形参(将实参的值传递给形参,单向传递);形参获得值以后,无论值是否改变,均与形参无关! 引用传递:用引用作为形参,在函数调用时发生的参数传递,称为引用传递.引用:int i,j;int &amp;ri=i;j=10;ri=j;相当于i=j;(可以理解为取地址). 内联函数 内联函数适用于功能简单,规模较小,使用频繁的函数(非递归). 内联函数不是在调用时发生控制转移,而是在编译时将函数体嵌入在每一个调用处. 语法:inline void a(int x);(显式声明). 函数重载 形参必须不同!!! 函数名相同,形参的个数或类型不同.功能相近,作用域相同,相同的函数名定义. 注意: 使用具有默认形参值的函数重载形式时,需要注意防止二义性 杂 运行栈:函数的形参和局部变量 运行栈中的数据分为一个个栈帧,每个栈帧对应一次函数调用;执行中的函数的栈帧,总处在运行栈的最顶端. 类与对象 对象 主要特点 :抽象,封装,继承,多态 抽象 对对象进行概括,抽出一类对象的公共性质并加以描述的过程. 抽象分为:数据抽象和行为抽象 数据抽象:描述此对象的属性和状态,即此对象区别与彼对象的特征 行为抽象:此对象的共同行为或功能特征 封装 封装:将抽象得到的数据和行为相结合,形成一个有机的整体;即将数据与操作数据的代码相结合,形成类,数据与函数均是类的成员. 封装使一部分成员充当类与外部的接口 继承 多态 分为:强制多态,重载多态,类型参数多态,包含多态 强制多态:数据类型转换 重载多态:函数重载,运算符重载 类型参数多态:函数模板,类模板 包含多态:虚函数 类 定义: class Students/*类名称*/ { public: /*外部接口*/ Students(); ~Students(); void output(); protectde: /*保护型成员*/ private: /*私有成员*/ int num; float scores; } //成员函数的实现 返回值 访问控制: 保护类型成员的性质与私有成员的性质相似,其差别在于继承过程中对产生的新类影响不同. 对象 声明: 类名 对象名; 类成员函数的默认值,一定要写在类定义中,而不能写在类定义之外的函数实现中. 构造函数与析构函数 #include&lt;iostream&gt; using namespace std; class Students { public: Students() { //普通无参构造函数 num = 0; scores = 0.0; } Students(int num1, float scores1); //普通有参构造函数 Students(Students&amp; Stu); //复制构造函数 void output(); private: int num; float scores; }; Students::Students(int num1, float scores1) { num = num1; scores = scores1; return; } Students::Students(Students&amp; Stu) { num = Stu.num; scores = Stu.scores; return; } void Students::output() //必须存在 { cout &lt;&lt; num &lt;&lt; \" \" &lt;&lt; scores &lt;&lt; endl; return; } int main(void) { Students s1(2, 1.0); //调用Students(int num1, float scores1); Students s2; //调用Students() Students s3(s1); //调用复制构造函数 s1.output(); s2.output(); s3.output(); return 0; } 或 #include&lt;iostream&gt; using namespace std; class Students { public: Students(int num1 = 0, float scores1 = 0.0) { //普通构造函数 num = num1; scores = scores1; } Students(Students&amp; Stu); //复制构造函数 ~Students(); //析构函数 void output(); private: int num; float scores; }; Students::Students(Students&amp; Stu) //复制构造函数的实现 { num = Stu.num; scores = Stu.scores; return; } void Students::output() //必须存在 { cout &lt;&lt; num &lt;&lt; \" \" &lt;&lt; scores &lt;&lt; endl; return; } int main(void) { Students s1(2, 1.0); //调用普通构造函数 Students s2; //调用普通构造函数 Students s3(s1); //调用复制构造函数 s1.output(); s2.output(); s3.output(); return 0; } 用构造函数定义的类型转换(显式类型转换)需要在构造函数声明前加上explicit 或 #include&lt;iostream&gt; using namespace std; class Students { public: Students(int num1 = 0, float scores1 = 0.0) :num(num1), scores(scores1) { } //普通构造函数 通过初始化列表来初始化 Students(Students&amp; Stu); //复制构造函数 //~Students(); //析构函数 void output(); private: int num; float scores; }; Students::Students(Students&amp; Stu) //复制构造函数的实现 { num = Stu.num; scores = Stu.scores; return; } void Students::output() //必须存在 { cout &lt;&lt; num &lt;&lt; \" \" &lt;&lt; scores &lt;&lt; endl; return; } int main(void) { Students s1(2, 1.0); //调用普通构造函数 Students s2; //调用普通构造函数 Students s3(s1); //调用复制构造函数 s1.output(); s2.output(); s3.output(); return 0; } 初始化列表见课本P117底部 类的组合 组合类构造函数的定义为: 类名::类名(形参表):内嵌对象(形参表),内嵌对象(形参表) UML图形标识 暂略 结构体与联合体 结构体 暂略 联合体 联合体的全部数据成员共享同一组内存单元,即联合体变量中的成员同时至多只有一个是有意义的 union /*联合体名称*/ { public:/*默认*/ protected: /*保护型成员*/ private: /*私有成员*/ }; 位域 位域:允许将类中的多个数据成员打包,使不同成员可以共享相同的字节的机制. 定义方式: 数据类型说明符 成员名 : 位数 限制:bool,char,int,enum类型的成员 数据的共享与保护 作用域 函数原型作用域 局部作用域 局部变量: 具有局部作用域的变量 类作用域 命名空间作用域 namespace 命名空间名{ 各种声明(函数声明,类声明) } 或 using 命名空间名 :: 标识符名 using namespace 命名空间名 全局变量:具有命名空间作用域的变量 作用域可见性 标识符声明在前,引用在后 在具有包含关系的作用域中声明了同名标识符,则外层标识符在内层不可见 生存期 静态生存期 对象的生存期与程序的运行期相同 在命名空间作用域中声明的对象均具有静态生存期 若在局部作用域中声明具有静态生存期 需要使用关键字static 定义时未指定初值的基本类型静态生存期变量,会被初始化为0 动态生存期 类的静态成员 静态数据成员 类的静态数据成员具有静态生存期 关键字:static 在类的定义中仅仅对静态数据成员进行引用性声明, 必须在命名空间作用域的地方进行类名限定定义性声明,此时可进行初始化 例如: int Point::count=0; 静态函数成员 静态成员函数可以通过类名或对象名来调用(习惯于通过类名调用) 非静态成员函数只能通过对象名来调用 关键字:static 静态成员函数能直接访问该类的静态数据和函数成员,如要访问非静态成员,必须通过对象名 访问属性 类的友元 关键字: friend 友元函数 友元类 1.友元关系不能传递 2,友元关系是单向的 B类是A类的友元,B类的成员函数可以访问A类的私有与保护数据,但A类成员函数不能访问B类的私有与保护数据 3.友元关系不能被继承 共享数据的保护 关键字: const 常对象 const 类型说明符 对象名; 常对象必须进行初始化,而且不能被更新 常成员函数 类型说明符 函数名(参数表) const; 常成员函数调用期间,目的对象均视为常对象,不管是否通过常对象调用 常数据成员 初始化只能通过调用构造函数的初始化列表来初始化 常引用 const 类型说明符&amp;引用名; 外部变量 关键字extern using namespace 语句不宜放在头文件中 指针 指向函数的指针 声明:数据类型 (*函数指针名) (形参表) 赋值:函数指针名=函数名 返回值相同,形参表相同 对象指针 声明:类名 * 对象指针名 应用: 对象指针名 -&gt; 成员名 this指针 隐含与每一个类中的非静态成员函数中,指向正在被成员函数操作的对象 类的多态性 重载多态 运算符重载 返回类型 operator 运算符 (形参表) { 函数体; } 类的继承与派生 派生类的定义 多继承 :有多个基类 单继承: 一个派生类只有一个直接基类 继承方式关键字:public (公有继承) protected(保护继承)private(私有继承,默认) 同名隐藏:派生类声明一个与基类成员同名的新成员,则该基类同名成员会被隐藏 访问控制 公有继承私有成员不可直接访问,而公有成员与保护成员的访问属性不变 访问属性 基类的 私有继承 保护继承 奇技 取整函数 向下取整函数:得到不大于一个数的最大整数 声明:&lt;cmath&gt; 应用:四舍五入取整:m=floor(a+0.5); 保留小数点后两位:m=floor(a*100+0.5)/100; 向上取整函数:得到一个不小于一个数的最小整数 声明:&lt;cmath&gt; ceil round 四舍五入到最近的整数 Π的定义 const double Pi=acos(-1.0); 不借助任何变量实现变量交换 a=a+b;//a=a0;b=b0; a=a0+b0; b=a-b;//b=a0+b0-b0=a0; a=a-b;//a=a0+b0-a0=b0; //没什么软用 //或简写成 a^=b^=a^=b;//......","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://lan-shanguiyao.github.io/tags/C/"}]}],"categories":[{"name":"WSL","slug":"WSL","permalink":"https://lan-shanguiyao.github.io/categories/WSL/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://lan-shanguiyao.github.io/tags/Windows/"},{"name":".NET","slug":"NET","permalink":"https://lan-shanguiyao.github.io/tags/NET/"},{"name":"C#","slug":"C","permalink":"https://lan-shanguiyao.github.io/tags/C/"},{"name":"WSL","slug":"WSL","permalink":"https://lan-shanguiyao.github.io/tags/WSL/"},{"name":"C++","slug":"C","permalink":"https://lan-shanguiyao.github.io/tags/C/"},{"name":"折腾","slug":"折腾","permalink":"https://lan-shanguiyao.github.io/tags/%E6%8A%98%E8%85%BE/"},{"name":"Music","slug":"Music","permalink":"https://lan-shanguiyao.github.io/tags/Music/"}]}