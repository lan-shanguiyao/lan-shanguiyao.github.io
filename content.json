{"meta":{"title":"遁岚的博客","subtitle":"DunLan's Island","description":"当群星数亿年前爆炸时，它们形成了这个世界中的一切。我们所认知的一切，都是星辰。","author":"DunLan","url":"https://lan-shanguiyao.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-02-07T03:31:06.000Z","updated":"2020-02-07T05:47:07.352Z","comments":true,"path":"categories/index.html","permalink":"https://lan-shanguiyao.github.io/categories/","excerpt":"","text":""},{"title":"tags","date":"2020-02-07T03:29:04.000Z","updated":"2020-02-07T05:46:45.616Z","comments":true,"path":"tags/index.html","permalink":"https://lan-shanguiyao.github.io/tags/","excerpt":"","text":""},{"title":"about","date":"2020-02-07T03:30:32.000Z","updated":"2020-02-07T03:33:03.727Z","comments":true,"path":"about/index.html","permalink":"https://lan-shanguiyao.github.io/about/","excerpt":"","text":""}],"posts":[{"title":"如何在Win10中禁止对特定网站的访问","slug":"baidu","date":"2020-04-16T06:14:15.000Z","updated":"2020-04-16T07:57:23.219Z","comments":true,"path":"2020/04/16/baidu/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/04/16/baidu/","excerpt":"","text":"如何在Win10中禁止对特定网站的访问 网上的教程，大多数都是说证书被吊销后如何访问一个网站，今天我要反其道而行之，要主动吊销一个网站的证书，禁止在我的电脑上访问它。 本文以百度为例，讲述如何在你的电脑上阻止对百度的访问 本文由知乎上的 这篇文章 启发而来，这两种方法有异曲同工之妙，不过本文更注重的是与百度这个公司所有服务的屏蔽，而不单单是软件。但本文无法避免由不安全的上网习惯或者疏忽导致的软件捆绑安装问题 首先需要打开百度 然后导出百度的证书到本机 本文能实现的效果也如下图所示 打开设置，搜索“证书”并打开“计算机证书” （此处可能需要Win10专业版） 导入百度的证书 至此 www.baidu.com 在电脑上就被彻底屏蔽掉了","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://lan-shanguiyao.github.io/tags/Windows/"}]},{"title":"Win10 WSL中搭建.NET开发环境","slug":"WSLtitle","date":"2020-03-03T11:24:22.000Z","updated":"2020-03-03T11:29:01.866Z","comments":true,"path":"2020/03/03/WSLtitle/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/03/03/WSLtitle/","excerpt":"","text":"Win10 WSL中搭建.NET开发环境 此方法适用于电脑运行虚拟机卡顿（比如我）或电脑剩余空间不足以安装虚拟机的同学。 优点：坑相对较少，节约内存、储存空间 缺点：没有图形化界面等，仅支持 Win10 安装方法如下： Win10 开启 WSL Win10 版本需高于 1709 ，版本号在 “设置” -“系统”-“关于”里可以找到 在“控制面板”里找到并打开“启用或关闭 Windows 功能” ，然后滚动至底部，如截图所示，勾选 “适用于 Linux 的 Windows 子系统”，点击确定。它将会下载安装需要的包。 下载安装 Visual Studio Code 下载并安装 安装如下插件：C#；Remote-WSL、Remote-SSH 、Remote - SSH: Editing Configuration Files、Remote Development、Remote - Containers。剩余插件自行安装，比如Chinese (Simplified) Language Pack for Visual Studio Code等。 在 Win10 Microsoft Store 中搜索并安装 Ubuntu 搜索结果有多个 原则上安装哪一个并不影响使用，但为统一起见，建议安装 Ubuntu 通过查阅版本号可知为 Ubuntu 18.04.2 LTS 安装完成后自行设置用户名与密码 根据 Microsoft Docs ：Ubuntu 18.04 包管理器 - 安装 .NET Core 安装.NET Core ,最少安装完 .NET Core SDK ，也可以均安装。如有疑问，可以先自行查阅上文。 命令行命令举例: * 新建项目: `~$ dotnet new console -o myapp` * 运行项目: `~$ dotnet run` 剩余命令参考： https://dotnet.microsoft.com/learn/dotnet/hello-world-tutorial/next https://docs.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio-code 打开 VS Code，按下图操作，即可 大功告成,可以开始使用了。","categories":[],"tags":[{"name":".NET,C#,WSL","slug":"NET-C-WSL","permalink":"https://lan-shanguiyao.github.io/tags/NET-C-WSL/"}]},{"title":"数据结构与OOP课程设计题目 文件目录显示","slug":"title","date":"2020-02-17T03:54:01.000Z","updated":"2020-02-28T03:48:35.548Z","comments":true,"path":"2020/02/17/title/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/02/17/title/","excerpt":"","text":"数据结构与OOP课程设计题目 文件目录显示 问题描述 ​ 要求在给出Unix或windows下目录和文件信息的前提下，编程实现将其排列成一棵具有一定缩进的树。 解决问题 ​ 题目说了给出文件信息，我们可以读取文件信息，存到一颗 K-ary tree 中，在按一定的缩进输出就可以了，难点呢就是该如何建立一颗 K-ary tree ，子节点的数目是不确定的。除此之外没有啥难点。 ​ 但是，C++ 17 标准都出了，我们可以利用一下新出的特性嘛，这样，30行内解决问题岂不很爽。只需要借助 path 类中的几个相关函数，就可以解决问题了。当然，调用 cmd 中的 tree 命令也能做到这一点，代码量会更少。 ​ 三种方法的区别主要是在 cmd 是直接调用的系统命令 ，path 类中有一个C++已经帮我们写好的树形结构，而第三种则是我们自己去实现树形结构。 ​ 综上所述呢，这题是一道名副其实的水题。代码如下。 cmd #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;using namespace std;int main()&#123; string cdstr; cout &lt;&lt; \"输入文件夹路径\" &lt;&lt; endl; cin &gt;&gt; cdstr; cdstr = \"tree /f \" + cdstr; system(cdstr.c_str()); return 0;&#125; 用 C++ 17 中的标准库即可完成 //本项目基于 ISO C++17 标准#include &lt;iostream&gt;#include &lt;filesystem&gt;using namespace std;using namespace filesystem;inline void print(int n)&#123; for (int i = 0; i &lt; n; ++i) cout &lt;&lt; \" \";&#125;int main()&#123; string s; cout &lt;&lt; \"输入文件夹路径（绝对路径）：\" &lt;&lt; endl; cin &gt;&gt; s; path str(s); if (!exists(str)) &#123; return 1; &#125;//确认路径存在 directory_entry entry(str);//文件入口 recursive_directory_iterator list(str);//文件入口容器 for (auto&amp; it : list) &#123; print(list.depth()); cout &lt;&lt; it.path().filename() &lt;&lt; endl; &#125; return 0;&#125; 自己造的轮子 //本项目基于 ISO C++17 标准#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;fstream&gt;#include &lt;regex&gt;using namespace std;struct Node&#123; Node():parent(nullptr), flag(true), depth(0) &#123;&#125; Node(const string&amp; e): data(e), parent(nullptr), flag(true), depth(0) &#123;&#125; //data string data;//数据域 Node* parent;//父节点 bool flag;//是否可以有子节点，即，该节点是否为文件夹 vector&lt;Node*&gt;child;//子节点 unsigned depth;//树深,即当前节点所处的层数&#125;;//文件IOclass IO&#123;public: vector&lt;string&gt; FileData; void InPut(const string&amp; name) &#123; InFile.open(name, ios_base::in); //如果文件打开失败 if (!InFile.is_open()) &#123; cout &lt;&lt; \"File can't open\" &lt;&lt; endl; exit(EXIT_FAILURE); &#125; char a[501]; int i = 0; while (InFile.getline(a, sizeof(a))) FileData.push_back(a); InFile.clear(); InFile.close(); &#125; void OutPut(const string&amp; name, const vector&lt;string&gt;&amp; data)//输出文件名，输出的行数，输出的数据 &#123; OutFile.open(name, ios_base::out); for (unsigned i = 0; i &lt; data.size(); ++i) OutFile &lt;&lt; data[i] &lt;&lt; endl; OutFile.close(); &#125; //曲线救国,不符合 IO 类的通用性，慎用，使用时，三个函数必须全部使用 void OutInit1(const string&amp; filename) &#123; OutFile.open(filename, ios_base::out); &#125; void OutInit(const string&amp; data) &#123; OutFile &lt;&lt; data; &#125; void OutInit2() &#123; OutFile.close(); &#125;private: fstream InFile;//文件输入 ofstream OutFile;//文件输出 string FileName;//文件名&#125;;//一个KTree类的对象就是一个 k-ary treeclass KTree&#123;public: KTree():_size(0), _root(nullptr), _height(0) &#123;&#125; bool Empty() &#123; return !_root; &#125;//判空 Node* Root()const &#123; return _root; &#125;//root unsigned Size()const &#123; return _size; &#125;//size //插入 //插入根节点 Node* InsertAsRoot(const string&amp; e) &#123; _size = 1; return _root = new Node(e); &#125; //插入子节点 e 作为 x 的孩子插入 Node* InsertAsChild(const string&amp; e, Node* x) &#123; _size++; Node* a = new Node(e); a-&gt;parent = x; a-&gt;depth = x-&gt;depth + 1; x-&gt;child.push_back(a); return a; &#125; //遍历 void Trav(Node* e, IO&amp; io) &#123; out(e-&gt;depth, io);//利用层数来显示次序 io.OutInit(e-&gt;data); io.OutInit(\"\\n\"); if (e-&gt;child.empty()) return; for (unsigned i = 0; i &lt; e-&gt;child.size(); ++i) Trav(e-&gt;child[i], io); &#125; inline void out(unsigned x, IO&amp; io) &#123; for (unsigned i = 0; i &lt; x; ++i) io.OutInit(\" \"); &#125; //删除 //高度更新private: Node* _root;//root 节点 unsigned _size;//树的节点个数 unsigned _height;//树高&#125;;//输入数据处理，存入 k-ary tree 中void ProcessIn(const vector&lt;string&gt;&amp; data, KTree&amp; tree)&#123; for (unsigned i = 0; i &lt; data.size(); ++i) &#123; unsigned cnt = 0; auto res = data[i].find('\\\\', cnt); vector&lt;string&gt; s; while (res != string::npos) &#123; s.push_back(data[i].substr(cnt, res - cnt)); cnt = res + 1; res = data[i].find('\\\\', cnt); &#125; s.push_back(data[i].substr(cnt)); //后期优化掉下面的循环,似乎没法优化？！ if (i == 0) tree.InsertAsRoot(s[0]); Node* a = tree.Root(); for (unsigned j = 1; j &lt; s.size(); ++j) &#123; bool f = false; for (unsigned k = 0; k &lt; a-&gt;child.size(); ++k) &#123; if (s[j] == a-&gt;child[k]-&gt;data) &#123; f = true; a = a-&gt;child[k]; &#125; &#125; //没找到就作为子节点插入 if (!f) a = tree.InsertAsChild(s[j], a); &#125; &#125;&#125;int main()&#123; IO io; KTree tree; io.InPut(\"Input1.txt\"); ProcessIn(io.FileData, tree); io.OutInit1(\"Output.txt\"); tree.Trav(tree.Root(), io); io.OutInit2(); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://lan-shanguiyao.github.io/tags/C/"}]},{"title":"Last.fm","slug":"Last-fm","date":"2020-02-07T13:04:25.000Z","updated":"2020-03-10T07:57:46.000Z","comments":true,"path":"2020/02/07/Last-fm/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/02/07/Last-fm/","excerpt":"","text":"用 Last.fm 记录你听的每一首歌 起因 本来想用豆瓣来记录自己的听歌，但豆瓣上曲目混乱，遂作罢。于是开始使用 Last.fm 。 听歌平台 流媒体平台（按使用频率排序）：Apple Music、Listen1（聚合几乎国内所有主流音乐平台）、 Spotify 、QQ音乐、Google Play Music 本地播放： foobar2000 、 AIMP 、 Dopamine 下面是我个人的解决方案 解决方案 本地播放的解决方案 foobar2000 foobar2000 插件众多，不难找到一款同步到 Last.fm 的插件，我试过foo_audioscrobbler-1.4.7但不知是我电脑原因还是网络原因，始终不能成功。于是我在 Github 上抱着试试的心态找到了 foo_scrobble ，一切顺利，在此感谢开发者。 AIMP AIMP有自带的 Last.fm 但不知为何，记录不能正常进行，只能偶尔记录，AIMP的使用频率也不高，遂作罢。 Dopamine Dopamine 也有自带的 Last.fm ，这个可以正常工作。 流媒体平台的解决方案 Win10 Apple Music 需要使用官方的程序来进行记录，QQ音乐等平台有 Listen1 Android Android需要安装 Scroball for Last.fm 来记录，无论是本地播放还是流媒体播放都能胜任。","categories":[],"tags":[{"name":"折腾, Music","slug":"折腾-Music","permalink":"https://lan-shanguiyao.github.io/tags/%E6%8A%98%E8%85%BE-Music/"}]},{"title":"C++","slug":"C","date":"2020-02-07T09:04:37.000Z","updated":"2020-02-07T09:05:25.596Z","comments":true,"path":"2020/02/07/C/","link":"","permalink":"https://lan-shanguiyao.github.io/2020/02/07/C/","excerpt":"","text":"C++ 知识点 函数 main函数的形参被称为命令行参数,由操作系统启动程序时初始化,main函数的返回值最终传递给操作系统. 声明函数,形参表只需给出包含完整的类型信息即可,形参名可以省略(不推荐使用). 参数传递 值传递:函数调用时,用实参初始化形参(将实参的值传递给形参,单向传递);形参获得值以后,无论值是否改变,均与形参无关! 引用传递:用引用作为形参,在函数调用时发生的参数传递,称为引用传递.引用:int i,j;int &amp;ri=i;j=10;ri=j;相当于i=j;(可以理解为取地址). 内联函数 内联函数适用于功能简单,规模较小,使用频繁的函数(非递归). 内联函数不是在调用时发生控制转移,而是在编译时将函数体嵌入在每一个调用处. 语法:inline void a(int x);(显式声明). 函数重载 形参必须不同!!! 函数名相同,形参的个数或类型不同.功能相近,作用域相同,相同的函数名定义. 注意: 使用具有默认形参值的函数重载形式时,需要注意防止二义性 杂 运行栈:函数的形参和局部变量 运行栈中的数据分为一个个栈帧,每个栈帧对应一次函数调用;执行中的函数的栈帧,总处在运行栈的最顶端. 类与对象 对象 主要特点 :抽象,封装,继承,多态 抽象 对对象进行概括,抽出一类对象的公共性质并加以描述的过程. 抽象分为:数据抽象和行为抽象 数据抽象:描述此对象的属性和状态,即此对象区别与彼对象的特征 行为抽象:此对象的共同行为或功能特征 封装 封装:将抽象得到的数据和行为相结合,形成一个有机的整体;即将数据与操作数据的代码相结合,形成类,数据与函数均是类的成员. 封装使一部分成员充当类与外部的接口 继承 多态 分为:强制多态,重载多态,类型参数多态,包含多态 强制多态:数据类型转换 重载多态:函数重载,运算符重载 类型参数多态:函数模板,类模板 包含多态:虚函数 类 定义: class Students/*类名称*/&#123; public: /*外部接口*/ Students(); ~Students(); void output(); protectde: /*保护型成员*/ private: /*私有成员*/ int num; float scores;&#125;//成员函数的实现返回值 访问控制: 保护类型成员的性质与私有成员的性质相似,其差别在于继承过程中对产生的新类影响不同. 对象 声明: 类名 对象名; 类成员函数的默认值,一定要写在类定义中,而不能写在类定义之外的函数实现中. 构造函数与析构函数 #include&lt;iostream&gt;using namespace std;class Students&#123;public: Students() &#123; //普通无参构造函数 num = 0; scores = 0.0; &#125; Students(int num1, float scores1); //普通有参构造函数 Students(Students&amp; Stu); //复制构造函数 void output();private: int num; float scores;&#125;;Students::Students(int num1, float scores1)&#123; num = num1; scores = scores1; return;&#125;Students::Students(Students&amp; Stu)&#123; num = Stu.num; scores = Stu.scores; return;&#125;void Students::output() //必须存在&#123; cout &lt;&lt; num &lt;&lt; \" \" &lt;&lt; scores &lt;&lt; endl; return;&#125;int main(void) &#123; Students s1(2, 1.0); //调用Students(int num1, float scores1); Students s2; //调用Students() Students s3(s1); //调用复制构造函数 s1.output(); s2.output(); s3.output(); return 0;&#125; 或 #include&lt;iostream&gt;using namespace std;class Students&#123;public: Students(int num1 = 0, float scores1 = 0.0) &#123; //普通构造函数 num = num1; scores = scores1; &#125; Students(Students&amp; Stu); //复制构造函数 ~Students(); //析构函数 void output();private: int num; float scores;&#125;;Students::Students(Students&amp; Stu) //复制构造函数的实现&#123; num = Stu.num; scores = Stu.scores; return;&#125;void Students::output() //必须存在&#123; cout &lt;&lt; num &lt;&lt; \" \" &lt;&lt; scores &lt;&lt; endl; return;&#125;int main(void) &#123; Students s1(2, 1.0); //调用普通构造函数 Students s2; //调用普通构造函数 Students s3(s1); //调用复制构造函数 s1.output(); s2.output(); s3.output(); return 0;&#125; 用构造函数定义的类型转换(显式类型转换)需要在构造函数声明前加上explicit 或 #include&lt;iostream&gt;using namespace std;class Students&#123;public: Students(int num1 = 0, float scores1 = 0.0) :num(num1), scores(scores1) &#123; &#125; //普通构造函数 通过初始化列表来初始化 Students(Students&amp; Stu); //复制构造函数 //~Students(); //析构函数 void output();private: int num; float scores;&#125;;Students::Students(Students&amp; Stu) //复制构造函数的实现&#123; num = Stu.num; scores = Stu.scores; return;&#125;void Students::output() //必须存在&#123; cout &lt;&lt; num &lt;&lt; \" \" &lt;&lt; scores &lt;&lt; endl; return;&#125;int main(void) &#123; Students s1(2, 1.0); //调用普通构造函数 Students s2; //调用普通构造函数 Students s3(s1); //调用复制构造函数 s1.output(); s2.output(); s3.output(); return 0;&#125; 初始化列表见课本P117底部 类的组合 组合类构造函数的定义为: 类名::类名(形参表):内嵌对象(形参表),内嵌对象(形参表) UML图形标识 暂略 结构体与联合体 结构体 暂略 联合体 联合体的全部数据成员共享同一组内存单元,即联合体变量中的成员同时至多只有一个是有意义的 union /*联合体名称*/&#123;public:/*默认*/protected: /*保护型成员*/private: /*私有成员*/&#125;; 位域 位域:允许将类中的多个数据成员打包,使不同成员可以共享相同的字节的机制. 定义方式: 数据类型说明符 成员名 : 位数 限制:bool,char,int,enum类型的成员 数据的共享与保护 作用域 函数原型作用域 局部作用域 局部变量: 具有局部作用域的变量 类作用域 命名空间作用域 namespace 命名空间名&#123; 各种声明(函数声明,类声明)&#125; 或 using 命名空间名 :: 标识符名 using namespace 命名空间名 全局变量:具有命名空间作用域的变量 作用域可见性 标识符声明在前,引用在后 在具有包含关系的作用域中声明了同名标识符,则外层标识符在内层不可见 生存期 静态生存期 对象的生存期与程序的运行期相同 在命名空间作用域中声明的对象均具有静态生存期 若在局部作用域中声明具有静态生存期 需要使用关键字static 定义时未指定初值的基本类型静态生存期变量,会被初始化为0 动态生存期 类的静态成员 静态数据成员 类的静态数据成员具有静态生存期 关键字:static 在类的定义中仅仅对静态数据成员进行引用性声明, 必须在命名空间作用域的地方进行类名限定定义性声明,此时可进行初始化 例如: int Point::count=0; 静态函数成员 静态成员函数可以通过类名或对象名来调用(习惯于通过类名调用) 非静态成员函数只能通过对象名来调用 关键字:static 静态成员函数能直接访问该类的静态数据和函数成员,如要访问非静态成员,必须通过对象名 访问属性 类的友元 关键字: friend 友元函数 友元类 1.友元关系不能传递 2,友元关系是单向的 B类是A类的友元,B类的成员函数可以访问A类的私有与保护数据,但A类成员函数不能访问B类的私有与保护数据 3.友元关系不能被继承 共享数据的保护 关键字: const 常对象 const 类型说明符 对象名; 常对象必须进行初始化,而且不能被更新 常成员函数 类型说明符 函数名(参数表) const; 常成员函数调用期间,目的对象均视为常对象,不管是否通过常对象调用 常数据成员 初始化只能通过调用构造函数的初始化列表来初始化 常引用 const 类型说明符&amp;引用名; 外部变量 关键字extern using namespace 语句不宜放在头文件中 指针 指向函数的指针 声明:数据类型 (*函数指针名) (形参表) 赋值:函数指针名=函数名 返回值相同,形参表相同 对象指针 声明:类名 * 对象指针名 应用: 对象指针名 -&gt; 成员名 this指针 隐含与每一个类中的非静态成员函数中,指向正在被成员函数操作的对象 类的多态性 重载多态 运算符重载 返回类型 operator 运算符 (形参表)&#123; 函数体;&#125; 类的继承与派生 派生类的定义 多继承 :有多个基类 单继承: 一个派生类只有一个直接基类 继承方式关键字:public (公有继承) protected(保护继承)private(私有继承,默认) 同名隐藏:派生类声明一个与基类成员同名的新成员,则该基类同名成员会被隐藏 访问控制 公有继承私有成员不可直接访问,而公有成员与保护成员的访问属性不变 访问属性 基类的 私有继承 保护继承 奇技 取整函数 向下取整函数:得到不大于一个数的最大整数 声明:&lt;cmath&gt; 应用:四舍五入取整:m=floor(a+0.5); 保留小数点后两位:m=floor(a*100+0.5)/100; 向上取整函数:得到一个不小于一个数的最小整数 声明:&lt;cmath&gt; ceil round 四舍五入到最近的整数 Π的定义 const double Pi=acos(-1.0); 不借助任何变量实现变量交换 a&#x3D;a+b;&#x2F;&#x2F;a&#x3D;a0;b&#x3D;b0; a&#x3D;a0+b0;b&#x3D;a-b;&#x2F;&#x2F;b&#x3D;a0+b0-b0&#x3D;a0;a&#x3D;a-b;&#x2F;&#x2F;a&#x3D;a0+b0-a0&#x3D;b0;&#x2F;&#x2F;没什么软用&#x2F;&#x2F;或简写成a^&#x3D;b^&#x3D;a^&#x3D;b;&#x2F;&#x2F;......","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://lan-shanguiyao.github.io/tags/C/"}]}],"categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://lan-shanguiyao.github.io/tags/Windows/"},{"name":".NET,C#,WSL","slug":"NET-C-WSL","permalink":"https://lan-shanguiyao.github.io/tags/NET-C-WSL/"},{"name":"C++","slug":"C","permalink":"https://lan-shanguiyao.github.io/tags/C/"},{"name":"折腾, Music","slug":"折腾-Music","permalink":"https://lan-shanguiyao.github.io/tags/%E6%8A%98%E8%85%BE-Music/"}]}