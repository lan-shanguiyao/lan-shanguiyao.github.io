<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode 9.回文数</title>
      <link href="/2020/07/06/leetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>/2020/07/06/leetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode-9回文数"><a class="markdownIt-Anchor" href="#leetcode-9回文数"></a> leetcode 9.回文数</h1><h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><blockquote><p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">题目链接</a></p></blockquote><p>参考文章：</p><blockquote><p><a href="https://leetcode-cn.com/problems/palindrome-number/solution/ji-jian-jie-fa-by-ijzqardmbd-2/" target="_blank" rel="noopener">极简数学解法</a></p></blockquote><a id="more"></a><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>首先想到的是转换成字符串，判断是否回文，这样效率不是很高。因此，要换个办法。</p><p>有两种方法可以解决这个问题。首先可以求取给定数的逆序，判断与原数是否相等。还可以取数字的首位和末位依次比较。下面的三种解法均基于这两个办法。</p><h3 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h3><p>易得：当<code>x</code>小于<code>0</code>且是<code>10</code>的倍数时一定不为回文数</p><p>​当<code>x</code>小于<code>10</code>且大于<code>0</code>时一定是回文数</p><h4 id="解法1取数字的首位和末位依次比较"><a class="markdownIt-Anchor" href="#解法1取数字的首位和末位依次比较"></a> 解法1：取数字的首位和末位依次比较。</h4><p>首先需要解决的问题是如何在不转换成字符串的情况下求得数字位数。</p><p>设数字为<code>x</code>，数字位数为<code>n</code>，公式 $n=10^{\left \lfloor\log_{10}{x}\right\rfloor} $</p><p>取最后一位：<code>x%10</code>，取第一位：<code>x/n</code></p><p>每次循环去掉首位与末尾：<code>x=(x%n)/10</code></p><p>完整代码</p><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{    <span class="hljs-comment">//数学解法</span>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">10</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">log10</span>(x);    <span class="hljs-keyword">int</span> nn = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, n); <span class="hljs-comment">//求x的数量级</span>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>)    {        <span class="hljs-keyword">if</span> (x / nn != x % <span class="hljs-number">10</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        x = (x % nn) / <span class="hljs-number">10</span>;        nn /= <span class="hljs-number">100</span>;    }    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}</code></pre><h4 id="解法2-求取逆序数字"><a class="markdownIt-Anchor" href="#解法2-求取逆序数字"></a> 解法2 求取逆序数字</h4><p>直接上代码</p><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{    <span class="hljs-comment">//反转全部数字</span>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">10</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> a = x;    <span class="hljs-keyword">while</span> (a != <span class="hljs-number">0</span>)    {        ans = ans * <span class="hljs-number">10</span> + a % <span class="hljs-number">10</span>;        a /= <span class="hljs-number">10</span>;    }    <span class="hljs-keyword">return</span> x == ans;}</code></pre><p>此处有个问题：32位整数最大为<code>2147483647</code>，如果将其反转，则会发生溢出。所以<code>ans</code>采用<code>long</code>来存储。</p><h4 id="解法3-求取逆序一半的数字"><a class="markdownIt-Anchor" href="#解法3-求取逆序一半的数字"></a> 解法3 求取逆序一半的数字</h4><p>回文数的特点是具有对称性。我们完全可以反转一半的数字就能判断是否为回文数。</p><p>根据数字位数的不同可分为两种，奇数位和偶数位</p><p>举个例子：<code>123321</code>与<code>1234321</code></p><p><code>123321</code>是<code>123</code>与<code>123</code>进行比较；<code>1234321</code>是<code>1234</code>与<code>123</code>进行比较。可见奇数位需要去掉求得的逆序数的最后一位</p><p>循环的终止条件，当求得的逆序数比原数字大或相等时停止</p><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{    <span class="hljs-comment">//反转一半数字</span>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>))        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">10</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> a = x;    <span class="hljs-keyword">while</span> (ans &lt; a)    {        ans = ans * <span class="hljs-number">10</span> + a % <span class="hljs-number">10</span>;        a /= <span class="hljs-number">10</span>;    }    <span class="hljs-keyword">return</span> a == ans || a == ans / <span class="hljs-number">10</span>;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Win10中禁止对特定网站的访问</title>
      <link href="/2020/04/16/baidu/"/>
      <url>/2020/04/16/baidu/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在win10中禁止对特定网站的访问"><a class="markdownIt-Anchor" href="#如何在win10中禁止对特定网站的访问"></a> 如何在Win10中禁止对特定网站的访问</h1><p>网上的教程，大多数都是说证书被吊销后如何访问一个网站，今天我要反其道而行之，要主动吊销一个网站的证书，禁止在我的电脑上访问它。</p><a id="more"></a><p>本文以百度为例，讲述如何在你的电脑上阻止对百度的访问</p><p>本文由知乎上的 <a href="https://www.zhihu.com/question/26917038/answer/36005976" target="_blank" rel="noopener">这篇文章</a> 启发而来，这两种方法有异曲同工之妙，不过本文更注重的是与百度这个公司所有服务的屏蔽，而不单单是软件。但本文无法避免由不安全的上网习惯或者疏忽导致的软件捆绑安装问题</p><ol><li><p>首先需要打开百度 然后导出百度的证书到本机</p><p>本文能实现的效果也如下图所示</p><p><img src="https://i.loli.net/2020/04/16/s24Iri7HwLnF6gZ.png" alt="导出证书" /></p></li><li><p>打开设置，搜索“证书”并打开“计算机证书”</p><p>（此处可能需要Win10专业版）</p><p><img src="https://i.loli.net/2020/04/16/BlYq4xdEkNzI7vS.png" alt="" /></p></li><li><p>导入百度的证书</p><p><img src="https://i.loli.net/2020/04/16/8fFVhreHQgIyGXw.png" alt="" /></p></li></ol><p>至此 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 在电脑上就被彻底屏蔽掉了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10 WSL中搭建.NET开发环境</title>
      <link href="/2020/03/03/WSLtitle/"/>
      <url>/2020/03/03/WSLtitle/</url>
      
        <content type="html"><![CDATA[<h1 id="win10-wsl中搭建net开发环境"><a class="markdownIt-Anchor" href="#win10-wsl中搭建net开发环境"></a> Win10 WSL中搭建.NET开发环境</h1><p>此方法适用于电脑运行虚拟机卡顿（比如我）或电脑剩余空间不足以安装虚拟机的同学。</p><p>优点：坑相对较少，节约内存、储存空间</p><p>缺点：没有图形化界面等，<strong>仅支持 Win10</strong></p><a id="more"></a><p>安装方法如下：</p><ol><li><p>Win10 开启 WSL</p><ol><li><p>Win10 版本需高于 1709 ，版本号在 “设置” -“系统”-“关于”里可以找到</p> <img src="https://i.loli.net/2020/03/03/XRqi8SO5PhaNnyK.png" alt="image-20200302224202226" style="zoom:50%;" /></li><li><p>在“控制面板”里找到并打开“启用或关闭 Windows 功能” ，然后滚动至底部，如截图所示，勾选 “适用于 Linux 的 Windows 子系统”，点击确定。它将会下载安装需要的包。</p> <img src="https://i.loli.net/2020/03/03/2SNtgpFsDZzOvEj.png" alt="image-20200302224635964" style="zoom: 33%;" /></li></ol></li><li><p>下载安装 <a href="https://code.visualstudio.com/%5D" target="_blank" rel="noopener">Visual Studio Code</a></p><ol><li>下载并安装</li><li>安装如下插件：C#；Remote-WSL、Remote-SSH 、Remote - SSH: Editing Configuration Files、Remote Development、Remote - Containers。剩余插件自行安装，比如Chinese (Simplified) Language Pack for Visual Studio Code等。</li></ol></li><li><p>在 Win10 Microsoft Store 中搜索并安装 Ubuntu 搜索结果有多个 原则上安装哪一个并不影响使用，但为统一起见，建议安装 Ubuntu</p> <img src="https://i.loli.net/2020/03/03/zvF8fEmGRO6NM9o.png" alt="image-20200302222653716" style="zoom: 33%;" /><p>通过查阅版本号可知为 Ubuntu 18.04.2 LTS</p> <img src="https://i.loli.net/2020/03/03/1sjRCqrI8BtocMQ.png" alt="image-20200302223303530" style="zoom:50%;" /><p>安装完成后自行设置用户名与密码</p><p>根据 Microsoft Docs ：<a href="https://docs.microsoft.com/zh-cn/dotnet/core/install/linux-package-manager-ubuntu-1804" target="_blank" rel="noopener">Ubuntu 18.04 包管理器 - 安装 .NET Core</a> <a href="http://xn--49sq66h.NET" target="_blank" rel="noopener">安装.NET</a> Core ,最少安装完 .NET Core SDK ，也可以均安装。如有疑问，可以先自行查阅上文。</p> <img src="https://i.loli.net/2020/03/03/ZL5Ro2QsF6PnJ4V.png" alt="image-20200302225445263" style="zoom: 67%;" /><p>命令行命令举例:</p><pre><code> * 新建项目: `~$ dotnet new console -o myapp`   * 运行项目: `~$ dotnet run` </code></pre><p>剩余命令参考：</p><p><a href="https://dotnet.microsoft.com/learn/dotnet/hello-world-tutorial/next" target="_blank" rel="noopener">https://dotnet.microsoft.com/learn/dotnet/hello-world-tutorial/next</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio-code" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/core/tutorials/with-visual-studio-code</a></p></li><li><p>打开 VS　Code，按下图操作，即可</p> <img src="https://i.loli.net/2020/03/03/E3zuSBkQsa78gAX.png" alt="image-20200302225837024" style="zoom:50%;" /> <img src="C:\Users\bixue\OneDrive\码农的自我修养\Markdown\image-20200302230044769.png" alt="image-20200302230044769" style="zoom: 33%;" /></li><li><p>大功告成,可以开始使用了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> WSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> C# </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与OOP课程设计题目 文件目录显示</title>
      <link href="/2020/02/17/oop/"/>
      <url>/2020/02/17/oop/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与oop课程设计题目-文件目录显示"><a class="markdownIt-Anchor" href="#数据结构与oop课程设计题目-文件目录显示"></a> 数据结构与OOP课程设计题目 文件目录显示</h1><h3 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h3><p>​要求在给出Unix或windows下目录和文件信息的前提下，编程实现将其排列成一棵具有一定缩进的树。</p><a id="more"></a><h3 id="解决问题"><a class="markdownIt-Anchor" href="#解决问题"></a> 解决问题</h3><p>​题目说了给出文件信息，我们可以读取文件信息，存到一颗 <a href="https://en.wikipedia.org/wiki/M-ary_tree" target="_blank" rel="noopener">K-ary tree</a> 中，在按一定的缩进输出就可以了，难点呢就是该如何建立一颗 K-ary tree ，子节点的数目是不确定的。除此之外没有啥难点。</p><p>​但是，C++ 17 标准都出了，我们可以利用一下新出的特性嘛，这样，30行内解决问题岂不很爽。只需要借助 <a href="https://zh.cppreference.com/w/cpp/filesystem/path" target="_blank" rel="noopener">path</a> 类中的几个相关函数，就可以解决问题了。当然，调用 cmd 中的 tree 命令也能做到这一点，代码量会更少。</p><p>​三种方法的区别主要是在 cmd 是直接调用的系统命令 ，path 类中有一个C++已经帮我们写好的树形结构，而第三种则是我们自己去实现树形结构。</p><p>​综上所述呢，这题是一道名副其实的水题。代码如下。</p><ol><li><p>cmd</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-built_in">string</span> cdstr;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"输入文件夹路径"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; cdstr;    cdstr = <span class="hljs-string">"tree /f "</span> + cdstr;    system(cdstr.c_str());    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></li><li><p>用 C++ 17 中的标准库即可完成</p><pre class="highlight"><code class="c++"><span class="hljs-comment">//本项目基于 ISO C++17 标准</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;filesystem&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> filesystem;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"    "</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-built_in">string</span> s;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"输入文件夹路径（绝对路径）："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; s;    <span class="hljs-function">path <span class="hljs-title">str</span><span class="hljs-params">(s)</span></span>;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">exists</span>(str)) { <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; }<span class="hljs-comment">//确认路径存在</span>    <span class="hljs-function">directory_entry <span class="hljs-title">entry</span><span class="hljs-params">(str)</span></span>;<span class="hljs-comment">//文件入口</span>    <span class="hljs-function">recursive_directory_iterator <span class="hljs-title">list</span><span class="hljs-params">(str)</span></span>;<span class="hljs-comment">//文件入口容器</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : <span class="hljs-built_in">list</span>)    {        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>.depth());        <span class="hljs-built_in">cout</span> &lt;&lt; it.path().filename() &lt;&lt; <span class="hljs-built_in">endl</span>;    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></li><li><p>自己造的轮子</p><pre class="highlight"><code class="c++"><span class="hljs-comment">//本项目基于 ISO C++17 标准</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;regex&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>    Node():parent(<span class="hljs-literal">nullptr</span>), flag(<span class="hljs-literal">true</span>), depth(<span class="hljs-number">0</span>) {}    Node(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; e): data(e), parent(<span class="hljs-literal">nullptr</span>), flag(<span class="hljs-literal">true</span>), depth(<span class="hljs-number">0</span>) {}    <span class="hljs-comment">//data</span>    <span class="hljs-built_in">string</span> data;<span class="hljs-comment">//数据域</span>    Node* parent;<span class="hljs-comment">//父节点</span>    <span class="hljs-keyword">bool</span> flag;<span class="hljs-comment">//是否可以有子节点，即，该节点是否为文件夹</span>    <span class="hljs-built_in">vector</span>&lt;Node*&gt;child;<span class="hljs-comment">//子节点</span>    <span class="hljs-keyword">unsigned</span> depth;<span class="hljs-comment">//树深,即当前节点所处的层数</span>};<span class="hljs-comment">//文件IO</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IO</span>{</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; FileData;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InPut</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name)</span>    </span>{        InFile.<span class="hljs-built_in">open</span>(name, ios_base::in);        <span class="hljs-comment">//如果文件打开失败</span>        <span class="hljs-keyword">if</span> (!InFile.is_open())        {            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"File can't open"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);        }        <span class="hljs-keyword">char</span> a[<span class="hljs-number">501</span>];        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (InFile.getline(a, <span class="hljs-keyword">sizeof</span>(a)))            FileData.push_back(a);        InFile.<span class="hljs-built_in">clear</span>();        InFile.<span class="hljs-built_in">close</span>();    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; name, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; data)</span><span class="hljs-comment">//输出文件名，输出的行数，输出的数据</span>    </span>{        OutFile.<span class="hljs-built_in">open</span>(name, ios_base::out);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); ++i)            OutFile &lt;&lt; data[i] &lt;&lt; <span class="hljs-built_in">endl</span>;        OutFile.<span class="hljs-built_in">close</span>();    }    <span class="hljs-comment">//曲线救国,不符合 IO 类的通用性，慎用，使用时，三个函数必须全部使用</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OutInit1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; filename)</span> </span>{ OutFile.<span class="hljs-built_in">open</span>(filename, ios_base::out); }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OutInit</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; data)</span> </span>{ OutFile &lt;&lt; data; }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OutInit2</span><span class="hljs-params">()</span> </span>{ OutFile.<span class="hljs-built_in">close</span>(); }<span class="hljs-keyword">private</span>:    fstream InFile;<span class="hljs-comment">//文件输入</span>    ofstream OutFile;<span class="hljs-comment">//文件输出</span>    <span class="hljs-built_in">string</span> FileName;<span class="hljs-comment">//文件名</span>};<span class="hljs-comment">//一个KTree类的对象就是一个 k-ary tree</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KTree</span>{</span><span class="hljs-keyword">public</span>:    KTree():_size(<span class="hljs-number">0</span>), _root(<span class="hljs-literal">nullptr</span>), _height(<span class="hljs-number">0</span>) {}    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> !_root; }<span class="hljs-comment">//判空</span>    <span class="hljs-function">Node* <span class="hljs-title">Root</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> _root; }<span class="hljs-comment">//root</span>    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> _size; }<span class="hljs-comment">//size</span>    <span class="hljs-comment">//插入</span>    <span class="hljs-comment">//插入根节点</span>    <span class="hljs-function">Node* <span class="hljs-title">InsertAsRoot</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; e)</span>    </span>{        _size = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> _root = <span class="hljs-keyword">new</span> Node(e);    }    <span class="hljs-comment">//插入子节点 e 作为 x 的孩子插入</span>    <span class="hljs-function">Node* <span class="hljs-title">InsertAsChild</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; e, Node* x)</span>    </span>{        _size++;        Node* a = <span class="hljs-keyword">new</span> Node(e);        a-&gt;parent = x;        a-&gt;depth = x-&gt;depth + <span class="hljs-number">1</span>;        x-&gt;child.push_back(a);        <span class="hljs-keyword">return</span> a;    }    <span class="hljs-comment">//遍历</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Trav</span><span class="hljs-params">(Node* e, IO&amp; io)</span>    </span>{        out(e-&gt;depth, io);<span class="hljs-comment">//利用层数来显示次序</span>        io.OutInit(e-&gt;data);        io.OutInit(<span class="hljs-string">"\n"</span>);        <span class="hljs-keyword">if</span> (e-&gt;child.empty())            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; e-&gt;child.<span class="hljs-built_in">size</span>(); ++i)            Trav(e-&gt;child[i], io);    }    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> x, IO&amp; io)</span>    </span>{        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; x; ++i)            io.OutInit(<span class="hljs-string">"    "</span>);    }    <span class="hljs-comment">//删除</span>    <span class="hljs-comment">//高度更新</span><span class="hljs-keyword">private</span>:    Node* _root;<span class="hljs-comment">//root 节点</span>    <span class="hljs-keyword">unsigned</span> _size;<span class="hljs-comment">//树的节点个数</span>    <span class="hljs-keyword">unsigned</span> _height;<span class="hljs-comment">//树高</span>};<span class="hljs-comment">//输入数据处理，存入 k-ary tree 中</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessIn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; data, KTree&amp; tree)</span></span>{    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); ++i)    {        <span class="hljs-keyword">unsigned</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">auto</span> res = data[i].<span class="hljs-built_in">find</span>(<span class="hljs-string">'\\'</span>, cnt);        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; s;        <span class="hljs-keyword">while</span> (res != <span class="hljs-built_in">string</span>::npos)        {            s.push_back(data[i].substr(cnt, res - cnt));            cnt = res + <span class="hljs-number">1</span>;            res = data[i].<span class="hljs-built_in">find</span>(<span class="hljs-string">'\\'</span>, cnt);        }        s.push_back(data[i].substr(cnt));        <span class="hljs-comment">//后期优化掉下面的循环,似乎没法优化？！</span>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)            tree.InsertAsRoot(s[<span class="hljs-number">0</span>]);        Node* a = tree.Root();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> j = <span class="hljs-number">1</span>; j &lt; s.<span class="hljs-built_in">size</span>(); ++j)        {            <span class="hljs-keyword">bool</span> f = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> k = <span class="hljs-number">0</span>; k &lt; a-&gt;child.<span class="hljs-built_in">size</span>(); ++k)            {                <span class="hljs-keyword">if</span> (s[j] == a-&gt;child[k]-&gt;data)                {                    f = <span class="hljs-literal">true</span>;                    a = a-&gt;child[k];                }            }            <span class="hljs-comment">//没找到就作为子节点插入</span>            <span class="hljs-keyword">if</span> (!f)                a = tree.InsertAsChild(s[j], a);        }    }}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    IO io;    KTree tree;    io.InPut(<span class="hljs-string">"Input1.txt"</span>);    ProcessIn(io.FileData, tree);    io.OutInit1(<span class="hljs-string">"Output.txt"</span>);    tree.Trav(tree.Root(), io);    io.OutInit2();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Last.fm</title>
      <link href="/2020/02/07/Last-fm/"/>
      <url>/2020/02/07/Last-fm/</url>
      
        <content type="html"><![CDATA[<h1 id="用-lastfm-记录你听的每一首歌"><a class="markdownIt-Anchor" href="#用-lastfm-记录你听的每一首歌"></a> 用 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 记录你听的每一首歌</h1><h2 id="lastfm"><a class="markdownIt-Anchor" href="#lastfm"></a> <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 是什么</h2><p><a href="https://www.last.fm/zh/home" target="_blank" rel="noopener">Last.fm</a> 是一个以英国为总部的网络电台和音乐社区。</p><a id="more"></a><p><a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 使用的音乐推荐方式称为“<a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> Scrobbler”，该系统提供安装在用户的电脑播放程序（支持 iTunes、Winamp、Windows Media Player、Foobar2000 等）或随身听设备的插件，记录（scrobbling）用户收听的每一首歌（在线流电台或本地音乐文件）的信息，发送回 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 数据库，并以其创建该用户的个人音乐品味，显示在该站提供予用户的个人网页上。该站亦提供多种社交网络服务，可让用户推荐或收听合其喜好的音乐。</p><blockquote><p>以上来自 <a href="https://zh.wikipedia.org/wiki/Last.fm" target="_blank" rel="noopener">维基百科</a>中对 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 的介绍。</p></blockquote><h2 id="我是如何与-lastfm-相遇的"><a class="markdownIt-Anchor" href="#我是如何与-lastfm-相遇的"></a> 我是如何与 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 相遇的</h2><p>我是想寻找一个平台，来记录自己听歌的数量的，曲目信息足够多并且要准确，支持的音乐平台要多，最好能实现自动记录<s>就是懒</s>，如果有听歌榜单之类的就更好啦。</p><p>一开始是选择的豆瓣，无奈豆瓣曲目相当混乱，只能寻找其他平台。然后找到了 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> ，经过一段时间的使用后 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 主要是一下几点吸引了我：</p><h3 id="美观漂亮的音乐榜单"><a class="markdownIt-Anchor" href="#美观漂亮的音乐榜单"></a> 美观漂亮的音乐榜单</h3><p>今年许多音乐平台纷纷推出了年度音乐榜单，比如网易云音乐、QQ音乐等等。由于我主要使用的是 Apple Music 很少使用网易云与QQ音乐，而 Apple Music 虽然有一个年度听歌排行榜，但是没有好看的报表分析（<s>就是馋他们的报表分析</s>）。</p><p><img src="https://i.loli.net/2020/03/12/4dRtoQ8KvGEgArf.png" alt="Last.fm 每周音乐报告" /></p><h3 id="记录歌曲准确及时"><a class="markdownIt-Anchor" href="#记录歌曲准确及时"></a> 记录歌曲准确及时</h3><p><a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 在这一点上做的相当不错，基本只要配置好了同步功能，同步很快而且很准（甚至准的有点过了）。目前我在 Android 与 Windows 上听过的歌都能记录到 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 上。</p><h3 id="lastfm-2"><a class="markdownIt-Anchor" href="#lastfm-2"></a> <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 还具有推荐功能，这也是我发现新歌曲的一大途径。</h3><img src="https://i.loli.net/2020/03/12/eDhfWqyYwT9n3ct.png" alt="Last.fm 的首页推荐" style="zoom:50%;" /><h3 id="lastfm-3"><a class="markdownIt-Anchor" href="#lastfm-3"></a> <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 能很好的配合 Spotify</h3><p>对于以后<s>要使用</s>正在使用 Spotify 的我是一个很不错的选择。使用 Spotify 的童鞋请直接看 <a href="#Spotify">这里</a> 。</p><p><a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 还具有一定的社交功能，这个十分有限，毕竟是 Web2.0时代的网站了。</p><h2 id="使用-lastfm-随时随地记录你听过的歌曲"><a class="markdownIt-Anchor" href="#使用-lastfm-随时随地记录你听过的歌曲"></a> 使用 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 随时随地记录你听过的歌曲</h2><p>在 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 网站上我们可以找到官方支持的平台</p><p><img src="https://i.loli.net/2020/03/12/XM9wG2bZ4SqOxtP.png" alt="Last.fm 官方支持的平台" /></p><p>很遗憾，出(yi)乎(liao)意(zhi)料(zhong)的没有国内的各大流媒体平台。不过即便如此，  <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 依然可以满足我的需求。</p><h3 id="同步最方便支持音乐平台最多的android-平台"><a class="markdownIt-Anchor" href="#同步最方便支持音乐平台最多的android-平台"></a> 同步最方便支持音乐平台最多的：Android 平台</h3><p>​<a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 官方提供的程序 <a href="https://play.google.com/store/apps/details?id=fm.last.android" target="_blank" rel="noopener">Last.fm</a> 只提供了 Spotify、Rdio等平台的支持，所以还需要下载另一个 <a href="https://play.google.com/store/apps/details?id=com.peterjosling.scroball" target="_blank" rel="noopener">Scroball for Last.fm</a> 程序，它会监视通知栏来进行记录，所以，有时需要在设置中将播客app、视频app还有浏览器给关闭，防止误记录（使用 Spotify 的童鞋请先关掉这个软件里的 Spotify 记录选项）。</p><p>​这样，就能完成 Android 平台的记录，这个平台也几乎是我们听歌最常用的平台。很抱歉我手头没有 iOS 设备所以，我还不大清楚 iOS平台应该怎么样记录。<img src="https://i.loli.net/2020/03/12/kjg34XOKDxJGr5E.jpg" alt="设置中的界面" /></p><h3 id="window-平台"><a class="markdownIt-Anchor" href="#window-平台"></a> Window 平台</h3><p>Windows 平台分为以下两个方面：本地与流媒体</p><h4 id="本地播放"><a class="markdownIt-Anchor" href="#本地播放"></a> 本地播放：</h4><h5 id="foobar2000"><a class="markdownIt-Anchor" href="#foobar2000"></a> foobar2000</h5><p>这个我们可以在 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 网站上的 <a href="https://getsatisfaction.com/lastfm/topics/foobar2000-scrobbling" target="_blank" rel="noopener">这篇文章</a> 中找到教程。首先我们需要在 Github 上下载一个叫 <a href="https://github.com/gix/foo_scrobble" target="_blank" rel="noopener">foo_scrobble</a> 的插件，然后安装到 foobar2000中，安装过程我就不放图了。然后我们按 Ctrl+P，找到如下界面：然后点击橙色的框，此时会弹出浏览器界面，授予权限后，再点击一下，橙色的框会显示&quot;Clear authorization&quot;即完成授权（记得保存设置）。</p><p><img src="https://i.loli.net/2020/03/12/xS3vjKYVIQ6Dnha.png" alt="界面示意图" /></p><p><img src="https://i.loli.net/2020/03/12/Rfnvsj5Ed4WyQZ3.png" alt="授权的三种状态" /></p><h5 id="aimp"><a class="markdownIt-Anchor" href="#aimp"></a> AIMP</h5><p>AIMP在设置中可以找到 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> ，如下图所示，然后也会打开一个浏览器界面需要授权。不过我觉得 AIMP 在这方面做的体验不怎么样，个人建议使用 foobar2000 。</p><p><img src="https://i.loli.net/2020/03/12/TxkjhWctB3goHns.png" alt="AIMP" /></p><h5 id="musicbee"><a class="markdownIt-Anchor" href="#musicbee"></a> MusicBee</h5><p>刚刚接触这个软件，功能有待挖掘，设置 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 同步也是非常简单的，在首选项-&gt;设置里就可找到</p><p><img src="https://i.loli.net/2020/03/12/PVxd4egjavAUkKL.png" alt="MusicBee" /></p><h4 id="流媒体平台"><a class="markdownIt-Anchor" href="#流媒体平台"></a> 流媒体平台：</h4><h5 id="listen1"><a class="markdownIt-Anchor" href="#listen1"></a> Listen1</h5><p>关于它的详细描述，可以参见少数派之前的两篇文章 <a href="https://sspai.com/post/34149" target="_blank" rel="noopener">Listen 1，整合三大音乐平台的 Chrome 扩展 | App+1</a> 、<a href="https://sspai.com/post/43058" target="_blank" rel="noopener">Windows 上的良心国产应用，我们又帮你找了这 5 款</a></p><p>关于它的 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 设置也非常简单，点击连接，在浏览器页面上完成授权即可。</p><p><img src="https://i.loli.net/2020/03/12/nty2xzMEoTgwdl3.png" alt="Listen1" /></p><h5 id="网易云与qq音乐"><a class="markdownIt-Anchor" href="#网易云与qq音乐"></a> 网易云与QQ音乐</h5><p>关于网易云音乐与QQ音乐，很遗憾目前关于记录客户端的音乐播放<s>没有好办法</s>没有办法。</p><p>如果能在 Web 进行播放，有以下两个<a href="https://web-scrobbler.github.io/" target="_blank" rel="noopener">插件</a>与<a href="https://justan.github.io/gmscrobber/" target="_blank" rel="noopener">脚本</a>可以实现记录。</p><h5 id="apple-music"><a class="markdownIt-Anchor" href="#apple-music"></a> Apple Music</h5><p>我对 Apple Music 处于又爱又恨的状态，它与 Spotify 是我认为目前最好的两个音乐流媒体服务（仅个人观点，不喜勿喷），它不用翻墙，价格便宜，曲库全、配合 Apple 家产品使用很舒服（<s>假装我有一台iPhone</s>）；但是 iTunes 在 Windows 上是真的难用，内存占用出奇的高，一个听歌软件你能吃到1G内存？？？还有苹果服务的连接速度与质量也一言难尽，但是，还是要说一句&quot;真香&quot;。</p><p>对于苹果感人的优化与网络连接速度，我选择使用 Apple Music Webapp 来解决这个问题。我个人推荐 <a href="https://github.com/Musish/Musish" target="_blank" rel="noopener">Musish</a> 整体界面设计与使用体验都很不错，当然也能连接到 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 在右上角是设置里就能看到，与前面的方式一样，在此不多做赘述。</p><p>如果，非要用 Windows 上的 iTunes 听歌，就需要下载 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 的 <a href="https://www.last.fm/zh/about/trackmymusic" target="_blank" rel="noopener">官方客户端</a> 来进行记录，登陆账号后即可开始。</p><h5 id="spotify"><a class="markdownIt-Anchor" href="#spotify"></a> Spotify</h5><p>在 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 的<a href="https://www.last.fm/zh/about/trackmymusic#spotify" target="_blank" rel="noopener">这个页面</a>上，找到 Spotify ，点击连接，在弹出的浏览器页面中完成授权后，可看到下图，如图所示，我们不再需要记录的app，一个都不需要。（u1s1 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 配合 Spotify 使用是真的爽）。</p><p><img src="https://i.loli.net/2020/03/12/T8GNhESxZFm3Hgu.png" alt="Spotify" /></p><p>更多音乐平台连接 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 方式可以在<a href="https://getsatisfaction.com/lastfm/topics/more-ways-to-scrobble" target="_blank" rel="noopener">这儿</a>找到。</p><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>我在二月初使用的 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 至今，每周我都会看 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 的收听报告。感觉这就像周记一样记录着你每一周在音乐上的点滴。</p><p>同时我还时不时的去看看 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 的推荐，去发现一些新的歌手，新的歌曲。这些新的发现也会被记录到 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 上，形成一个推动。这样就一定程度上解决了歌荒的问题。</p><p>我个人认为 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 最重要的一点就是你的音乐记录彻底与流媒体平台切割开来，对某一平台的粘性可以下降到最低，某一平台一旦你觉得不好了，可以随时换掉。你也不再需要某一平台告诉你，你喜欢听什么歌曲。你所有的听歌记录全都被你自己掌控着。</p><p>我期待着我看到 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 2021年度报表的那一刻。</p><p>你是不是 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 用户呢，又有什么关于 <a href="http://Last.fm" target="_blank" rel="noopener">Last.fm</a> 想分享的呢？欢迎在评论区分享。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 折腾 </tag>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2020/02/07/C/"/>
      <url>/2020/02/07/C/</url>
      
        <content type="html"><![CDATA[<h1 id="c"><a class="markdownIt-Anchor" href="#c"></a> <strong>C++</strong></h1><h2 id="知识点"><a class="markdownIt-Anchor" href="#知识点"></a> <strong>知识点</strong></h2><a id="more"></a><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> <strong>函数</strong></h3><p> main函数的形参被称为命令行参数,由操作系统启动程序时初始化,main函数的返回值最终传递给操作系统.<br /> 声明函数,形参表只需给出包含完整的类型信息即可,形参名可以省略(不推荐使用).</p><ol><li><strong>参数传递</strong></li></ol><p> 值传递:函数调用时,用实参初始化形参(将实参的值传递给形参,单向传递);形参获得值以后,无论值是否改变,均与形参无关!<br /> 引用传递:用引用作为形参,在函数调用时发生的参数传递,称为引用传递.引用:<code>int i,j;int &amp;ri=i;j=10;ri=j;</code>相当于<code>i=j;</code>(可以理解为取地址).</p><ol start="3"><li><strong>内联函数</strong></li></ol><p> 内联函数适用于功能简单,规模较小,使用频繁的函数(非递归).<br /> 内联函数不是在调用时发生控制转移,而是在编译时将函数体嵌入在每一个调用处.<br /> 语法:<code>inline void a(int x);</code>(显式声明).</p><ol start="4"><li><strong>函数重载</strong></li></ol><p>  <strong>形参必须不同!!!</strong> 函数名相同,形参的个数或类型不同.功能相近,作用域相同,相同的函数名定义.<br /> 注意: 使用具有默认形参值的函数重载形式时,需要注意防止二义性</p><ol start="5"><li><strong>杂</strong></li></ol><p> <strong>运行栈</strong>:函数的形参和局部变量<br /> 运行栈中的数据分为一个个栈帧,每个栈帧对应一次函数调用;执行中的函数的栈帧,总处在运行栈的最顶端.</p><hr /><h3 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> <strong>类与对象</strong></h3><ol><li><strong>对象</strong></li></ol><p> <strong>主要特点</strong> :抽象,封装,继承,多态</p><ul><li>抽象</li></ul><p> 对对象进行概括,抽出一类对象的公共性质并加以描述的过程.<br /> 抽象分为:数据抽象和行为抽象<br /> 数据抽象:描述此对象的属性和状态,即此对象区别与彼对象的特征<br /> 行为抽象:此对象的共同行为或功能特征</p><ul><li><strong>封装</strong></li></ul><p> 封装:将抽象得到的数据和行为相结合,形成一个有机的整体;即将数据与操作数据的代码相结合,形成类,数据与函数均是类的成员.<br /> 封装使一部分成员充当类与外部的接口</p><ul><li><p><strong>继承</strong></p></li><li><p><strong>多态</strong></p></li></ul><p> 分为:强制多态,重载多态,类型参数多态,包含多态<br /> 强制多态:数据类型转换<br /> 重载多态:函数重载,运算符重载<br /> 类型参数多态:函数模板,类模板<br /> 包含多态:虚函数</p><ol start="2"><li><strong>类</strong></li></ol><p> 定义:</p><pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>/*类名称*/{</span>    <span class="hljs-keyword">public</span>: <span class="hljs-comment">/*外部接口*/</span>        Students();        ~Students();        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span>;            protectde:        <span class="hljs-comment">/*保护型成员*/</span>    <span class="hljs-keyword">private</span>:    <span class="hljs-comment">/*私有成员*/</span>        <span class="hljs-keyword">int</span> num;        <span class="hljs-keyword">float</span> scores;}<span class="hljs-comment">//成员函数的实现</span>返回值</code></pre><p> 访问控制:<br /> 保护类型成员的性质与私有成员的性质相似,其差别在于继承过程中对产生的新类影响不同.</p><ol start="3"><li><strong>对象</strong></li></ol><p> 声明:<br /> 类名 对象名;</p><p>类成员函数的默认值,一定要写在类定义中,而不能写在类定义之外的函数实现中.</p><ul><li><strong>构造函数与析构函数</strong></li></ul><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>{</span><span class="hljs-keyword">public</span>:Students() {<span class="hljs-comment">//普通无参构造函数</span>num = <span class="hljs-number">0</span>;scores = <span class="hljs-number">0.0</span>;}Students(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">float</span> scores1);<span class="hljs-comment">//普通有参构造函数</span>Students(Students&amp; Stu);<span class="hljs-comment">//复制构造函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> num;<span class="hljs-keyword">float</span> scores;};Students::Students(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">float</span> scores1){num = num1;scores = scores1;<span class="hljs-keyword">return</span>;}Students::Students(Students&amp; Stu){num = Stu.num;scores = Stu.scores;<span class="hljs-keyword">return</span>;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Students::output</span><span class="hljs-params">()</span><span class="hljs-comment">//必须存在</span></span>{<span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; scores &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{<span class="hljs-function">Students <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1.0</span>)</span></span>;<span class="hljs-comment">//调用Students(int num1, float scores1);</span>Students s2;<span class="hljs-comment">//调用Students()</span><span class="hljs-function">Students <span class="hljs-title">s3</span><span class="hljs-params">(s1)</span></span>;<span class="hljs-comment">//调用复制构造函数</span>s1.output();s2.output();s3.output();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p> 或</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>{</span><span class="hljs-keyword">public</span>:Students(<span class="hljs-keyword">int</span> num1 = <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span> scores1 = <span class="hljs-number">0.0</span>) {<span class="hljs-comment">//普通构造函数</span>num = num1;scores = scores1;}Students(Students&amp; Stu);<span class="hljs-comment">//复制构造函数</span>~Students();<span class="hljs-comment">//析构函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> num;<span class="hljs-keyword">float</span> scores;};Students::Students(Students&amp; Stu)<span class="hljs-comment">//复制构造函数的实现</span>{num = Stu.num;scores = Stu.scores;<span class="hljs-keyword">return</span>;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Students::output</span><span class="hljs-params">()</span><span class="hljs-comment">//必须存在</span></span>{<span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; scores &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{<span class="hljs-function">Students <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1.0</span>)</span></span>;<span class="hljs-comment">//调用普通构造函数</span>Students s2;<span class="hljs-comment">//调用普通构造函数</span><span class="hljs-function">Students <span class="hljs-title">s3</span><span class="hljs-params">(s1)</span></span>;<span class="hljs-comment">//调用复制构造函数</span>s1.output();s2.output();s3.output();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p> 用构造函数定义的类型转换(显式类型转换)需要在构造函数声明前加上<code>explicit</code></p><p>或</p><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span>{</span><span class="hljs-keyword">public</span>:Students(<span class="hljs-keyword">int</span> num1 = <span class="hljs-number">0</span>, <span class="hljs-keyword">float</span> scores1 = <span class="hljs-number">0.0</span>) :num(num1), scores(scores1) { }<span class="hljs-comment">//普通构造函数 通过初始化列表来初始化</span>Students(Students&amp; Stu);<span class="hljs-comment">//复制构造函数</span><span class="hljs-comment">//~Students();//析构函数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">private</span>:<span class="hljs-keyword">int</span> num;<span class="hljs-keyword">float</span> scores;};Students::Students(Students&amp; Stu)<span class="hljs-comment">//复制构造函数的实现</span>{num = Stu.num;scores = Stu.scores;<span class="hljs-keyword">return</span>;}<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Students::output</span><span class="hljs-params">()</span><span class="hljs-comment">//必须存在</span></span>{<span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; scores &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{<span class="hljs-function">Students <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1.0</span>)</span></span>;<span class="hljs-comment">//调用普通构造函数</span>Students s2;<span class="hljs-comment">//调用普通构造函数</span><span class="hljs-function">Students <span class="hljs-title">s3</span><span class="hljs-params">(s1)</span></span>;<span class="hljs-comment">//调用复制构造函数</span>s1.output();s2.output();s3.output();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><blockquote><p>初始化列表见课本P117底部</p></blockquote><ul><li><strong>类的组合</strong></li></ul><p> 组合类构造函数的定义为:<br />类名::类名(形参表):内嵌对象(形参表),内嵌对象(形参表)</p><ol start="4"><li><strong>UML图形标识</strong></li></ol><p>暂略</p><ol start="5"><li><strong>结构体与联合体</strong></li></ol><ul><li><strong>结构体</strong></li></ul><p>暂略</p><ul><li><strong>联合体</strong></li></ul><p> 联合体的全部数据成员共享同一组内存单元,即<strong>联合体变量中的成员同时至多只有一个是有意义的</strong></p><pre class="highlight"><code class="c++"><span class="hljs-keyword">union</span> <span class="hljs-comment">/*联合体名称*/</span>{<span class="hljs-keyword">public</span>:<span class="hljs-comment">/*默认*/</span><span class="hljs-keyword">protected</span>:<span class="hljs-comment">/*保护型成员*/</span><span class="hljs-keyword">private</span>:<span class="hljs-comment">/*私有成员*/</span>};</code></pre><ol start="6"><li><strong>位域</strong></li></ol><p> 位域:允许将类中的多个数据成员打包,使不同成员可以共享相同的字节的机制.<br /> 定义方式:  <code>数据类型说明符 成员名 : 位数</code><br /> 限制:bool,char,int,enum类型的成员</p><h3 id="数据的共享与保护"><a class="markdownIt-Anchor" href="#数据的共享与保护"></a> <strong>数据的共享与保护</strong></h3><ol><li><strong>作用域</strong></li></ol><ul><li><p><strong>函数原型作用域</strong></p></li><li><p><strong>局部作用域</strong></p></li></ul><p>局部变量: 具有局部作用域的变量</p><ul><li><p><strong>类作用域</strong></p></li><li><p><strong>命名空间作用域</strong></p></li></ul><pre class="highlight"><code class="c++"><span class="hljs-keyword">namespace</span> 命名空间名{各种声明(函数声明,类声明)}</code></pre><p>或<br /><code>using 命名空间名 :: 标识符名</code><br /><code>using namespace 命名空间名</code></p><p>全局变量:具有命名空间作用域的变量</p><ul><li><strong>作用域可见性</strong></li></ul><p>标识符声明在前,引用在后<br />在具有包含关系的作用域中声明了同名标识符,则外层标识符在内层不可见</p><ol start="2"><li><strong>生存期</strong></li></ol><ul><li><strong>静态生存期</strong></li></ul><p>对象的生存期与程序的运行期相同</p><p>在命名空间作用域中声明的对象均具有静态生存期</p><p>若在局部作用域中声明具有静态生存期 需要使用关键字<code>static</code></p><p>定义时未指定初值的基本类型静态生存期变量,会被初始化为0</p><ul><li><p><strong>动态生存期</strong></p></li><li><p><strong>类的静态成员</strong></p></li><li><p>静态数据成员</p></li></ul><p>类的静态数据成员具有静态生存期<br />关键字:<code>static</code><br />在类的定义中仅仅对静态数据成员进行<strong>引用性声明</strong>,<br />必须在<strong>命名空间作用域</strong>的地方进行<strong>类名限定定义性声明</strong>,此时可进行初始化<br />例如: <code>int Point::count=0;</code></p><ul><li>静态函数成员</li></ul><p>静态成员函数可以通过<strong>类名或对象名</strong>来调用(习惯于通过类名调用)<br />非静态成员函数<strong>只能通过对象名</strong>来调用<br />关键字:<code>static</code><br />静态成员函数能直接访问该类的静态数据和函数成员,如要访问非静态成员,必须通过对象名</p><blockquote><p><a id="访问属性"> </a>  <span id="jump">访问属性</span></p></blockquote><ol start="3"><li><strong>类的友元</strong></li></ol><p>关键字: <code>friend</code></p><ul><li>友元函数</li><li>友元类</li></ul><p>1.友元关系不能传递<br />2,友元关系是单向的<br />B类是A类的友元,B类的成员函数可以访问A类的私有与保护数据,但A类成员函数不能访问B类的私有与保护数据<br />3.友元关系不能被继承</p><ol start="4"><li><strong>共享数据的保护</strong></li></ol><p>关键字: <code>const</code></p><ul><li><strong>常对象</strong></li></ul><p><code>const 类型说明符 对象名;</code><br /><strong>常对象必须进行初始化,而且不能被更新</strong></p><ul><li><strong>常成员函数</strong></li></ul><p><code>类型说明符 函数名(参数表) const;</code><br />常成员函数调用期间,目的对象均视为常对象,不管是否通过常对象调用</p><ul><li><strong>常数据成员</strong></li></ul><p>初始化只能通过调用构造函数的初始化列表来初始化</p><ul><li><strong>常引用</strong></li></ul><p><code>const 类型说明符&amp;引用名;</code></p><ul><li>外部变量</li></ul><p>关键字<code>extern</code></p><blockquote><p>using namespace 语句不宜放在头文件中</p></blockquote><hr /><ol><li><strong>指针</strong></li></ol><ul><li><strong>指向函数的指针</strong></li></ul><p>声明:<code>数据类型 (*函数指针名) (形参表)</code></p><p>赋值:<code>函数指针名=函数名</code></p><p>返回值相同,形参表相同</p><ul><li><strong>对象指针</strong></li></ul><p>声明:<code>类名 * 对象指针名</code></p><p>应用: <code>对象指针名 -&gt; 成员名</code></p><ul><li>this指针</li></ul><p>隐含与每一个类中的非静态成员函数中,指向正在被成员函数操作的对象</p><h3 id="类的多态性"><a class="markdownIt-Anchor" href="#类的多态性"></a> <strong>类的多态性</strong></h3><ol><li><strong>重载多态</strong></li></ol><ul><li>运算符重载</li></ul><pre class="highlight"><code class="c++">返回类型 <span class="hljs-keyword">operator</span> 运算符 (形参表){    函数体;}</code></pre><h3 id="类的继承与派生"><a class="markdownIt-Anchor" href="#类的继承与派生"></a> <strong>类的继承与派生</strong></h3><ol><li><strong>派生类的定义</strong></li></ol><pre class="highlight"><code class="c++">   </code></pre><ul><li>多继承 :有多个基类</li><li>单继承: 一个派生类只有一个直接基类</li><li>继承方式关键字:<code>public</code> (公有继承) <code>protected</code>(保护继承)<code>private</code>(私有继承,默认)</li><li>同名隐藏:派生类声明一个与基类成员同名的新成员,则该基类同名成员会被隐藏</li></ul><ol start="2"><li><strong>访问控制</strong></li></ol><ul><li>公有继承私有成员不可<strong>直接</strong>访问,而公有成员与保护成员的访问属性不变</li></ul><blockquote><p><a href="#jump">访问属性</a></p></blockquote><p>基类的</p><ul><li>私有继承</li><li>保护继承</li></ul><hr /><hr /><hr /><h2 id="奇技"><a class="markdownIt-Anchor" href="#奇技"></a> <strong>奇技</strong></h2><ul><li><strong>取整函数</strong></li></ul><p> 向下取整函数:得到不大于一个数的最大整数<br />声明:<code>&lt;cmath&gt;</code><br />应用:四舍五入取整:<code>m=floor(a+0.5);</code><br />保留小数点后两位:<code>m=floor(a*100+0.5)/100;</code><br /> 向上取整函数:得到一个不小于一个数的最小整数<br />声明:<code>&lt;cmath&gt;</code><br /><code>ceil</code></p><p><code>round</code><br />四舍五入到最近的整数</p><ul><li><strong>Π的定义</strong></li></ul><p><code>const double Pi=acos(-1.0);</code></p><ul><li>不借助任何变量实现变量交换</li></ul><pre class="highlight"><code class="">a=a+b;//a=a0;b=b0; a=a0+b0;b=a-b;//b=a0+b0-b0=a0;a=a-b;//a=a0+b0-a0=b0;//没什么软用//或简写成a^=b^=a^=b;//......</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
